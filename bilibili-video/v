#!python3.10
import json, os, requests, subprocess, sys
from datetime import datetime
from urllib.parse import urlparse

# yet another bilibili video downloader, making use of the famous you-get downloader.
#
# video version of bilibili live stream replacer (yabai)[https://github.com/FreskyZ/yabai],
# they also share similar functionality and design principle to open result with local video player.
#
# this project is motivated from the stupid bug that I cannot watch bilibili video in browser on pc,
# the web page just become dead at a particular time after page content is loaded,
# not like common bug that everything goes wrong if serious bug happens in web page development process,
# it seems to die before video element actually starts to play, even F12 cannot open (or if you open in advance,
# nothing special prints), and the whole browser become slow to respond until tab is closed several seconds
# after close button is closed, I assume either bilibili or edge makes this bug, or even both of them, because
# both of them looks like will make this kind of error according to their recent years or months of behavior.

# video player, I'm calling windows video player from wsl
PLAYER = '/mnt/c/Program Files/DAUM/PotPlayer/PotPlayerMini64.exe'
# danmaku2ass install location, convert danmaku xml to ass subtitle
DANMAKU_CONVERTER = '/usr/local/bin/danmaku2ass'

# TODO: 
# 1. remove use of you-get and change to simple text processing
#    and simple large file download library (I'm not insterested in implementing progress bar)
# 2. use danmaku2ass as library or implement by myself or use a video player with danmaku support
# 3. use shutil instead of os.system(mv)
# 4. find more resolution option of video, 480p is really kind of small,
#    while 1080p is kind of large in file size, 720p should be ok
# 5. try implement play while downloading

if len(sys.argv) != 2:
    print(f'Usage: {sys.argv[0]} https://www.bilibili.com/video/BVxxxxxxxx')
    exit(0)

def validate(condition: bool, message: str):
    if not condition:
        print(f'v error: {message}')
        exit(1)

url = urlparse(sys.argv[1])
url = url._replace(query = '')
validate(url.scheme == 'https', 'invalid url, expect https, does bilibili currently support non https?')
validate(url.netloc in ('www.bilibili.com', 'bilibili.com'), 'invalid url, unknown website')
validate(url.path.startswith('/video/'), 'invalid url, not video url')

# this is before fetch data by myself and that video data already contains both avid and bvid and cid
def bv2av(bvid: str):
    ''' input should not include 'BV', result does not include 'av' '''
    validate(len(bvid) == 10, 'invalid bvid')
    avid = 0
    for i, j in enumerate([11, 10, 3, 8, 4, 6]):
        avid += 'fZodR9XQDSUm21yCkr6zBqiveYah8bt4xsWpHnJE7jL5VG3guMTKNPAwcF'.find(bvid[j]) * 58 ** i
    return f'{(avid - 8728348608) ^ 177451812}'
# avid = bv2av(url.path[9:])
# print(f'v: av{avid}')

session = requests.Session()
response = session.get(url.geturl())
validate(response.status_code == 200, f'failed to open {url.geturl()}: {response.status_code}')
validate(response.text.startswith('<!DOCTYPE html>'), f'failed to open {url.geturl()}: {response.text}')

# TODO: change to https://api.bilibili.com/x/web-interface/view?aid={avid}
initial_state_position = response.text.find('__INITIAL_STATE__=')
validate(initial_state_position >= 0, f'failed to open {url.geturl()}: not find __INITIAL_STATE__')
# json start from right of assignment
initial_state_position += 18
# json.loads does not support ignore extra data
initial_state = None
try:
    initial_state = json.loads(response.text[initial_state_position:])
except json.decoder.JSONDecodeError as ex:
    if ex.msg != 'Extra data':
        raise
    initial_state = json.loads(response.text[initial_state_position:initial_state_position + ex.pos])

play_info_position = response.text.find('__playinfo__=')
validate(initial_state_position >= 0, f'failed to open {url.geturl()}: not find __playinfo__')
play_info_position += 13
play_info = None
try:
    play_info = json.loads(response.text[play_info_position:])
except json.decoder.JSONDecodeError as ex:
    if ex.msg != 'Extra data':
        raise
    play_info = json.loads(response.text[play_info_position:play_info_position + ex.pos])
# play info has bilibili api common wrapper (code, message, data, etc.)
play_info = play_info['data']

avid = str(initial_state['aid'])
bvid: str = initial_state['bvid']
cid = str(initial_state['videoData']['cid'])
video_title: str = initial_state['videoData']['title']
video_cover: str = initial_state['videoData']['pic']
video_publish = datetime.fromtimestamp(initial_state['videoData']['pubdate'])
video_description: str = initial_state['videoData']['desc'] # desc_v2 seems no use
video_stat_view: int = initial_state['videoData']['stat']['view']
video_stat_like: int = initial_state['videoData']['stat']['like']
video_stat_coin: int = initial_state['videoData']['stat']['coin']
video_stat_favorite: int = initial_state['videoData']['stat']['favorite']
video_stat_danmaku: int = initial_state['videoData']['stat']['danmaku']
video_stat_reply: int = initial_state['videoData']['stat']['reply']
video_up_name: str = initial_state['upData']['name']
video_up_userid: int = initial_state['upData']['mid']

# result directory
directory = f'av{avid}'
if not os.path.exists(directory):
    os.mkdir(directory)

print(f'v: id: av{avid}/{bvid} ({cid})')
print(f'v: title: {video_title}')
print(f'v: publish time: {video_publish.strftime("%Y-%m-%d %H:%M:%S %z")}')
print(f'v: uploader: {video_up_name} (https://space.bilibili.com/{video_up_userid})')
print(f'v: stat: üëÄ {video_stat_view} üëç {video_stat_like} ‚ö™ {video_stat_coin} ‚ù§Ô∏è {video_stat_favorite} danmaku {video_stat_danmaku} reply {video_stat_reply}')
print(f'v: video desc:\n{video_description}')

# download cover
if not os.path.exists(f'{directory}/cover.jpg'):
    response = session.get(video_cover)
    validate(response.status_code == 200, f'failed to download video cover: {response.status_code}')
    validate(response.headers['Content-Type'] == 'image/jpeg', f'failed to download video cover: unknown content type {response.headers["Content-Type"]}')
    with open(f'{directory}/cover.jpg', 'wb') as f:
        f.write(response.content)

# download danmaku
if not os.path.exists(f'{directory}/danmaku.xml'):
    response = session.get(f'https://comment.bilibili.com/{cid}.xml')
    validate(response.status_code == 200, f'failed to download danmaku: {response.status_code}')
    validate(response.headers['Content-Type'] == 'text/xml', f'failed to download danmaku: unknown content type {response.headers["Content-Type"]}')
    with open(f'{directory}/danmaku.xml', 'wb') as f:
        f.write(response.content)

# response = requests.get(f'https://api.bilibili.com/x/player/playurl?avid={avid}&qn=0&type=&otype=json&fnver=0&fnval=16&fourk=1')

exit(0)


print(f'% you-get --json {url}')
info = json.loads(subprocess.check_output(['you-get', '--json', url]))
# single quote is hard to process in shell, you-get already changed them to underline
# also brackets
# but danmaku file forget to replace single quote
title = info['title'].replace('\'', '_').replace('[', '(').replace(']', ')')
# print(f'title: {title}')
danmaku_title = info['title'].replace('[', '(').replace(']', ')')
video_title = info['title'].replace('\'', '_').replace('[', '(').replace(']', ')')
if not os.path.exists(avid):
    os.mkdir(avid)

# only this 480p resolution available, use this
format = 'dash-flv480'
if format not in info['streams']:
    print('expect 480p mp4 available')
    exit(1)
if len(info['streams'][format]['src']) != 2:
    print('unexpect source url count, not 2 parts')
    exit(1)

def exec(command):
    print(f'% {command}')
    code = os.system(command)
    if code:
        print(f'command {command} failed with code {code}')
        exit(code)

# the download process, -o: output directory
exec(f'you-get -F {format} -o {avid} {url}')

# this is manual merge mp4 video and audio part
# but you-get actually does this if ffmpeg is installed (which was not when I wrote this)
if os.path.exists(f'{avid}/{video_title}[00].mp4'):
    # rename original video file
    exec(f'mv "{avid}/{video_title}[00].mp4" {avid}/videoonly.mp4')
    exec(f'mv "{avid}/{video_title}[01].mp4" {avid}/audioonly.mp4')
    # merge mp4 video and audio
    # `-c:v copy`: copy video encoding
    # `-c:a aac`: audio encoding aac
    # `-map 0:0`: copy input video 0 stream 0 to target video stream 0
    # `-map 1:0`: copy input video 1 stream 0 to target video stream 1
    exec(f'ffmpeg -i {avid}/videoonly.mp4 -i {avid}/audioonly.mp4 -c:v copy -c:a aac -map 0:0 -map 1:0 video.mp4')
else:
    # rename original video file
    exec(f'mv "{avid}/{video_title}.mp4" {avid}/video.mp4')
# rename original danmaku file
exec(f'mv "{avid}/{danmaku_title}.cmt.xml" {avid}/danmaku.xml')
# convert xml danmaku to ass danmaku
# -fs 12: font size 12
# -dm 10: normal danmaku move speed 10 (as duration for moving from right to left)
# -a 0.6: display alpha
exec(f'{DANMAKU_CONVERTER} {avid}/danmaku.xml -s840x480 -fn "Microsoft Yahei" -fs 14 -dm 12 -a 0.7 -o {avid}/video.ass')
# count danmaku, configparser does not support duplicate option, but count for substring occurance is enough
danmaku_count = 0
with open(f'{avid}/video.ass', 'r') as f:
    danmaku_count = f.read().count('Dialogue:')
# play video, should auto select subtitle
# this will immediately return when process created, and if not wait, this script process will not wait for that video player process to end
# redirect stdout and stderr because potplayer is logging to them
print(f'% playing {avid}/video.mp4 ({danmaku_count} danmaku)')
subprocess.Popen([PLAYER, f'{avid}/video.mp4'], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
